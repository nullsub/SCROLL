aspect Evaluation {

	public Player Tree.findPlayerByObject(Object object) {
		//System.out.println("Tree.findPlayerByObject()");

		for(Player p : this.getNaturals()) {
			Player ret = p.findPlayerByObject(object);
			if(ret != null) {
				return  ret;
			}
		}
		return null;
	}


	public Player Player.findPlayerByObject(Object object) {
		if(this.getObject() == object) {
			return this;
		}

		for(Player p : this.getRoles()) {
			Player ret = p.findPlayerByObject(object);
			if(ret != null) {
				return  ret;
			}
		}
		return null;
	}

	public Boolean Tree.removeNatural(Player player) {
		int toDelete = -1;
		for(Player p : this.getNaturals()) {
			if(p == player) {
				toDelete = this.getNaturals().getIndexOfChild(p);
				break;
			}
		}
		if(toDelete > -1) {
			this.getNaturals().removeChild(toDelete);
			return true;
		}
		return false;
	}

    private static Class<?> Player.getPrimitiveType(Class<?> retType)
    {
        if( retType == Boolean.class) return Boolean.TYPE;
        if( retType == Integer.class) return Integer.TYPE;
        if( retType == Byte.class) return Byte.TYPE;
        if( retType == Short.class) return Short.TYPE;
        if( retType == Character.class) return Character.TYPE;
        if( retType == Double.class) return Double.TYPE;
        if( retType == Long.class) return Long.TYPE;
        if( retType == Float.class) return Float.TYPE;
        return retType;
    }

    public FilterDispatchQuery Tree.findDispatchQuery(Player p) {

      if(p.getDispatchQuery() instanceof FilterDispatchQuery) {
          return (FilterDispatchQuery)p.getDispatchQuery();
      }
       Player pred = this.getPredecessor(p);
       if(pred != null) {
            return this.findDispatchQuery(pred);
       }
      return new FilterDispatchQuery();
    }

    public java.util.List<String> Tree.getExcludedClasses(Player p){
          java.util.List<String> excluded = new java.util.ArrayList<>();
          if(this.findDispatchQuery(p) != null && this.findDispatchQuery(p).getExcludes() != null) {
         for(ObjectWrapper o : this.findDispatchQuery(p).getExcludes().getClassesList()){
              excluded.add(o.getObject().toString());
          }
          }
          return excluded;
    }

        public java.util.List<String> Tree.getExcludedPlayers(Player p){
              java.util.List<String> excluded = new java.util.ArrayList<>();
          if(this.findDispatchQuery(p) != null && this.findDispatchQuery(p).getExcludes() != null) {
              for(ObjectWrapper o : this.findDispatchQuery(p).getExcludes().getPlayersList()){
                  excluded.add(o.getObject().toString());
              }
              }
              return excluded;
        }

            public java.util.List<String> Tree.getIncludedClasses(Player p){
                  java.util.List<String> excluded = new java.util.ArrayList<>();
                  if(this.findDispatchQuery(p) != null && this.findDispatchQuery(p).getExcludes() != null) {
                 for(ObjectWrapper o : this.findDispatchQuery(p).getIncludes().getClassesList()){
                      excluded.add(o.getObject().toString());
                  }
                  }
                  return excluded;
            }

                public java.util.List<String> Tree.getIncludedPlayers(Player p){
                      java.util.List<String> excluded = new java.util.ArrayList<>();
                  if(this.findDispatchQuery(p) != null && this.findDispatchQuery(p).getExcludes() != null) {
                      for(ObjectWrapper o : this.findDispatchQuery(p).getIncludes().getPlayersList()){
                          excluded.add(o.getObject().toString());
                      }
                  }
                  return excluded;
                }

	public scala.Tuple2<Object, java.lang.reflect.Method> Player.dispatchObjectForApply(Tree tree, String name, Object[] arguments) throws Exception {
        //System.out.println("dispatchObjectForApply() object: " + this.getObject().toString() + " method: " + name);
		java.util.List<Player> players = new java.util.ArrayList<Player>();
		players.addAll(scala.collection.JavaConversions.seqAsJavaList(this.getPlayers()));

		for(Player p: players) {
		         java.util.List<String> includedClasses = tree.getIncludedClasses(p);
                 java.util.List<String> includedPlayers = tree.getIncludedPlayers(p);

                if(!includedClasses.contains(p.getObject().getClass().toString()) && !includedPlayers.contains(p.getObject().toString())) {
                    java.util.List<String> excludedClasses = tree.getExcludedClasses(p);
                    java.util.List<String> excludedPlayers = tree.getExcludedPlayers(p);

		        if(excludedClasses.contains(p.getObject().getClass().toString())) {
                    continue;
                }
                if(excludedPlayers.contains(p.getObject().toString())) {
                    continue;
                }
                }
				for (java.lang.reflect.Method method : p.getObject().getClass().getDeclaredMethods()) {
					if(method.getName() == name && arguments.length == method.getParameterCount())  {
						int j = 0;
						boolean parametersCorrect = true;
						for(Object className : method.getParameterTypes()) {
							if(arguments[j] != null && Player.getPrimitiveType(arguments[j].getClass()) != className) {
								parametersCorrect = false;
							}
							j++;
						}
						if(parametersCorrect) {
							return new scala.Tuple2<>(p.getObject(), method);
						}
					}
			}
		}
		throw new Exception("dispatchObjectForApply: method not found!");
	}

	public Object Player.dispatchObjectForSelect(String name) throws Exception {
		java.util.List<Player> lastLevel = new java.util.ArrayList<Player>();
		lastLevel.add(this);

		do {
			java.util.List<Player> newLevel = new java.util.ArrayList<Player>();
			for(Player p : lastLevel) {
				try {
					java.lang.reflect.Field field = p.getObject().getClass().getDeclaredField(name);
					return p.getObject();
				} catch (Exception e) {

				}
				for(Player r : p.getRoles()) {
					newLevel.add(r);
				}
			}
			lastLevel = newLevel;
		} while(!lastLevel.isEmpty());

		throw new Exception("dispatchObjectForSelect: attribute not found!");
	}

	public Boolean Player.removeRole(Player player) {
		//System.out.println("removeRole()");
		int toDelete = -1;
		for(Player p : this.getRoles()) {
			if(p == player) {
				toDelete = this.getRoleList().getIndexOfChild(p);
				break;
			}
		}
		if(toDelete > -1) {
			this.getRoleList().removeChild(toDelete);
			return true;
		}

		return false;
	}

	public Player Tree.getPredecessor(Player player) {
		//System.out.println("getPredecessor()");

		for(Player n : this.getNaturals()) {
			java.util.List<Player> ret = scala.collection.JavaConversions.seqAsJavaList(n.getPlayers());
			for(Player p: ret) {
				for(Player role : p.getRoles()){
					if(role == player) {
						return p;
					}
				}
			}
		}
		return null;
	}

	public scala.collection.Seq<Player> Player.getPlayers() {

    		java.util.List<Player> lastLevel = new java.util.ArrayList<Player>();
    		java.util.List<Player> all = new java.util.ArrayList<Player>();
    		lastLevel.add(this);

    		do {
    			java.util.List<Player> newLevel = new java.util.ArrayList<Player>();
    			for(Player p : lastLevel) {
    			    for(Player r : p.getRoles()) {
    					newLevel.add(r);
    				}
    			}
    			all.addAll(lastLevel);
    			lastLevel = newLevel;
    		} while(!lastLevel.isEmpty());

    				java.util.Collections.reverse(all);


		    return scala.collection.JavaConverters.asScalaIteratorConverter(all.iterator()).asScala().toSeq();
    	}

	public scala.collection.Seq<Player> Player.successors() {
		//System.out.println("successors()");

		java.util.List<Player> list = new java.util.ArrayList<Player>();

		for(Player p : this.getRoles()){
			list.addAll(scala.collection.JavaConversions.seqAsJavaList(p.getPlayers()));
		}

		return scala.collection.JavaConverters.asScalaIteratorConverter(list.iterator()).asScala().toSeq();
	}
}
