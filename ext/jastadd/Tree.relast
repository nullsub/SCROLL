
Tree ::= Natural* DispatchQuery TraversalOrder;
abstract Player ::= Role* <Object:Object> [DispatchQuery];
Natural:Player ;
Role:Player ;

DispatchQuery ::= Includes:Filter Excludes:Filter;

Filter ::= Classes:ObjectWrapper* Players:ObjectWrapper* ;
ObjectWrapper ::= <Object:Object> ;

abstract TraversalOrder;
PostOrder:TraversalOrder;
InOrder:TraversalOrder;

rel DispatchQuery.Excluded* -> Player;
//rel DispatchQuery.Included* -> Player;

/*
Filtermöglichkeiten der DispatchQuery
- traversierungsfolge auswählbar (Bindungsreihenfolge(sodass selbst deeproles gewwählt werden, wenn sie später gebunden wurden, inOrder, postOrder)/sortierung
        enum für traversalOrder hinzufügen -> terminalSymbol
- nach typ filtern (bestimmte Rollen filtern/auswählen) -> include/exclude
- include/exclude --> support instanceOf and .equals

- einmal pro baum eine DispatchQuery speichern
*/


//suche der dispatchQuery mit vererbten Attributen: dispatchQuery()
/*
Beispiel Diagramme bauen (vektorgraphiken):
    Für dispatch
        distpachQuery
        Ablauf, reihenfolge

        player --> dispatchQuery().findMethod() aufgerufen
        Player --> findProperty
*/